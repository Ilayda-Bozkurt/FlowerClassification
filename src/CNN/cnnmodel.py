# -*- coding: utf-8 -*-
"""CNNmodel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13J8mnoonXhfrifnC_rEUEJ1WE7eeHA9b
"""

#Modeling

#Measures the accuracy of predictions
def accuracy(outputs, labels):
    _, preds = torch.max(outputs, dim=1)
    return torch.tensor(torch.sum(preds == labels).item() / len(preds))

#It is a base class that facilitates the training and validation of the model.
class ImageClassificationBase(nn.Module):
    ##Calculates loss for a batch during training
    def training_step(self, batch):
        images, labels = batch
        out = self(images)                  # Generate predictions
        loss = F.cross_entropy(out, labels) # Calculate loss
        return loss

    #Returns loss and accuracy during verification
    def validation_step(self, batch):
        images, labels = batch
        out = self(images)                    # Generate predictions
        loss = F.cross_entropy(out, labels)   # Calculate loss
        acc = accuracy(out, labels)           # Calculate accuracy
        return {'val_loss': loss.detach(), 'val_acc': acc}

    #Merges validation results at end of epoch
    def validation_epoch_end(self, outputs):
        batch_losses = [x['val_loss'] for x in outputs]
        epoch_loss = torch.stack(batch_losses).mean()   # Combine losses
        batch_accs = [x['val_acc'] for x in outputs]
        epoch_acc = torch.stack(batch_accs).mean()      # Combine accuracies
        return {'val_loss': epoch_loss.item(), 'val_acc': epoch_acc.item()}


    #It simply prints the results to the screen at the end of each epoch.
    def epoch_end(self, epoch, result):
        print("Epoch [{}], last_lr: {:.5f}, train_loss: {:.4f}, train_acc: {:.4f}, val_loss: {:.4f}, val_acc: {:.4f}".format(
            epoch, result['lrs'][-1], result['train_loss'], result['train_acc'], result['val_loss'], result['val_acc']))

#It is a CNN model defined for a flower classification problem.
#It inherits the ImageClassificationBase class, meaning it inherits the training and validation steps from the base class we wrote earlier.

class FlowersCNNModel(ImageClassificationBase):
    def __init__(self):
        super().__init__()
        self.linear_input = 784
        self.network = nn.Sequential(   #The main structure of the model is an nn.Sequential block, it allows layers to be applied sequentially
            #Convolutional Layers
            #3 different convolutional layers were used and ReLU activation was added after each layer. After each convolutional layer, dimension reduction was done using MaxPool
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.ReLU(),
            nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),   #150/2

            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(128, 128, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),   #75/2

            nn.Conv2d(128, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.Conv2d(256, 256, kernel_size=3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),   #37/2

            #Fully Connected Layers
            nn.Flatten(),

            nn.Linear(256*18*18, 1024),   #Since there are 256 channels left in 18x18 size
            nn.ReLU(),
            nn.Linear(1024, 512),
            nn.ReLU(),
            nn.Linear(512, 5))
    def forward(self, xb):
        return self.network(xb)